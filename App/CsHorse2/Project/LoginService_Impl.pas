unit LoginService_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I Remobjects.inc}

interface

uses
  Classes, SysUtils, Variants,
{$IFDEF APPDEBUG}
  CodeSiteLogging,
{$ENDIF}
{ App: }
  cbSrvClass, cbDesignPattern, cbLanguage, cbHrHelper,
{ ODAC: }
   Ora, MemDS, VirtualTable,
{ RemObjects: }
  uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions,
  uRORemoteDataModule, uROClient, CsHorse2Library_Intf, uROEventRepository,
  uROBinMessage;

type
  { TLoginService }
  TLoginService = class(TRORemoteDataModule, ILoginService)
    procedure RORemoteDataModuleCreate(Sender: TObject);
    procedure RORemoteDataModuleDestroy(Sender: TObject);
  private
    FReader: TOraQuery;
    FBuffer: TVirtualTable;
    function UpdateInfo(var AInfo: TLoginInfo; var AErrMsg: String): Boolean;
    function UpdateFromSession(const AInfo: TLoginInfo): TLoginInfo;
    procedure DoSrvCallback(const AInfo: TLoginInfo);
  protected
    { ILoginService methods }
    function Login(var AInfo: TLoginInfo; var AErrMsg: String): Boolean;
    procedure Logout(const AInfo: TLoginInfo);
    function GetClientParam: Binary;
    function GetOraSysDate(const ACompCode: String): String;
  end;

implementation

uses cbUtilis, cbROServerModule;

{$R *.dfm}

{ ---------------------------------------------------------------------------- }

{ LoginService }

procedure TLoginService.RORemoteDataModuleCreate(Sender: TObject);
begin
  FReader := TOraQuery.Create( nil );
  FReader.FetchAll := True;
  FBuffer := TVirtualTable.Create( nil );
end;

{ ---------------------------------------------------------------------------- }

procedure TLoginService.RORemoteDataModuleDestroy(Sender: TObject);
begin
  FReader.Session := nil;
  FReader.Free;
  FBuffer.Free;
end;

{ ---------------------------------------------------------------------------- }

function TLoginService.UpdateInfo(var AInfo: TLoginInfo; var AErrMsg: String): Boolean;
var
  aDbSession: TDbSession;
  aSql: String;
begin
  AErrMsg := EmptyStr;
  AInfo.SessionId := GUIDToString( Session.SessionID );
  TBufferHelper.CreateSqlText( biLoginInfo, aSql );
  aSql := Format( aSql, [AInfo.CompCode, AInfo.UserId] );
  aDbSession := ROServerModule.GetDbSession( AInfo.CompCode );
  Result := Assigned( aDbSession );
  if Result then
  begin
    FReader.Session := aDbSession.Connection;
    try
      FReader.SQL.Text := aSql;
      try
        FReader.Open;
        if ( not FReader.IsEmpty ) then
        begin
          AInfo.CompStr := FReader.FieldByName( 'CompStr' ).AsString;
          AInfo.UserName := FReader.FieldByName( 'UserName' ).AsString;
          AInfo.CompName := FReader.FieldByName( 'Description' ).AsString;
          AInfo.WorkClass := FReader.FieldByName( 'WorkClass' ).AsString;
          AInfo.GroupName := FReader.FieldByName( 'GroupName' ).AsString;
        end else
          AErrMsg := LanguageManager.Get( 'SServiceLoginErrorReason1' );
      except
        on E: Exception do
        begin
          Result := False;
          AErrMsg := E.Message;
          aDbSession.Connection.Close;
        end;
      end;
    finally
      FReader.Close;
      FReader.Session := nil;
      ROServerModule.ReleaseDbSession( AInfo.CompCode, aDbSession );
    end;
  end else
    AErrMsg := LanguageManager.Get( 'SServiceLoginErrorReason2' );
end;

{ ---------------------------------------------------------------------------- }

function TLoginService.UpdateFromSession(const AInfo: TLoginInfo): TLoginInfo;
begin
  Result := AInfo;
  if ( not Assigned( Result ) ) and ( not VarIsNull( Session.Values['AInfo'] ) ) then
    Result := TLoginInfo( Integer( Session['AInfo'] ) );
end;

{ ---------------------------------------------------------------------------- }

function TLoginService.Login(var AInfo: TLoginInfo; var AErrMsg: String): Boolean;
var
  aObj: TLoginInfo;
begin
  AErrMsg := EmptyStr;
  Result := UpdateInfo( AInfo, AErrMsg );
  if Result then
  begin
    if ( not VarIsNull( Session.Values['AInfo'] ) ) then
    begin
      aObj := TLoginInfo( Integer( Session.Values['AInfo'] ) );
      aObj.Free;
    end;
    aObj := TLoginInfo( AInfo.Clone );
    Session.Values['AInfo'] := Integer( aObj );
    LogUserBufferList.AddObject( AInfo.SessionId, aObj.Clone );
    ROServerModule.LoginMsgSubject.Info( LanguageManager.GetFmt( 'SServiceLoginSuccess',
      [AInfo.UserId, AInfo.UserName, AInfo.CompName] ) );
    RegisterEventClient( GUIDToString( ClientID ), 'ISrvCallbackEvent' );
    DoSrvCallback( aObj );
    {$IFDEF APPDEBUG}
       CodeSite.SendFmtMsg( 'User Session %s Login', [aObj.SessionId] );
    {$ENDIF}
  end else
  begin
    if ( AInfo.UserId <> EmptyStr ) and ( AInfo.UserName <> EmptyStr ) then
    begin
      ROServerModule.LoginMsgSubject.Error( LanguageManager.GetFmt( 'SServiceLoginError1',
        [AInfo.UserId, AInfo.UserName, AInfo.CompName, AErrMsg] ) );
    end else
    begin
      ROServerModule.LoginMsgSubject.Error( LanguageManager.GetFmt( 'SServiceLoginError2',
        [Nvl( AInfo.TermSIP, AInfo.IP ) , AErrMsg] ) );
    end;
    DestroySession;  
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TLoginService.Logout(const AInfo: TLoginInfo);
var
  aObj: TLoginInfo;
begin
  if ( not VarIsNull( Session.Values['AInfo'] ) ) then
  begin
    aObj := TLoginInfo( Integer( Session.Values['AInfo'] ) );
    aObj.Status := '0';
    LogUserBufferList.AddObject( AInfo.SessionId, aObj.Clone );
    ROServerModule.LoginMsgSubject.Info( LanguageManager.GetFmt( 'SServiceLogoutSuccess',
      [AInfo.UserId, AInfo.UserName, AInfo.CompName] ) );
    DoSrvCallback( aObj );
    UnregisterEventClient( GUIDToString( ClientID ), 'ISrvCallbackEvent' );
    Session.Values['AInfo'] := Null;
    {$IFDEF APPDEBUG}
      CodeSite.SendFmtMsg( 'User Session %s Logout', [aObj.SessionId] );
    {$ENDIF}
    aObj.Free;
  end;
  DestroySession;
end;

{ ---------------------------------------------------------------------------- }

function TLoginService.GetClientParam: Binary;
begin
  TBufferHelper.CreateFieldDefs( biClientParam, FBuffer );
  FBuffer.Append;
  FBuffer.FieldByName( 'AutoRefresh' ).AsBoolean := ROServerModule.ClientEnv.AutoRefresh;
  FBuffer.FieldByName( 'AuthorizeRefreshRate' ).AsInteger := ROServerModule.ClientEnv.AuthorizeRefreshRate;
  FBuffer.FieldByName( 'AnnRefreshRate' ).AsInteger := ROServerModule.ClientEnv.AnnRefreshRate;
  FBuffer.FieldByName( 'UserRefreshRate' ).AsInteger := ROServerModule.ClientEnv.UserRefreshRate;
  FBuffer.FieldByName( 'TryReconnectRate' ).AsInteger := ROServerModule.ClientEnv.TryReconnectRate;
  FBuffer.Post;
  Result := TROBinaryMemoryStream.Create;
  FBuffer.SaveToStream( Result, True );
  FBuffer.Clear;
end;

{ ---------------------------------------------------------------------------- }

function TLoginService.GetOraSysDate(const ACompCode: String): String;
var
  aDbSession: TDbSession;
begin
  Result := EmptyStr;
  aDbSession := ROServerModule.GetDbSession( ACompCode );
  if Assigned( aDbSession ) then
  begin
    FReader.Session := aDbSession.Connection;
    try
      FReader.SQL.Text := ' select to_char( sysdate, ''yyyy/mm/dd hh24:mi:ss'' ) from dual ';
      FReader.Open;
      Result := FReader.Fields[0].AsString;
    finally
      FReader.Close;
      FReader.Session := nil;
      ROServerModule.ReleaseDbSession( ACompCode, aDbSession );
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TLoginService.DoSrvCallback(const AInfo: TLoginInfo);
var
  aEvent: ISrvCallbackEvent_Writer;
  aIndex, aIndex2: Integer;
  aErrMsg: String;
  aInfo2: TLoginInfo;
begin
  aErrMsg := EmptyStr;
  aEvent := Self.EventRepository as ISrvCallbackEvent_Writer;
  aEvent.ExcludeSender := True;
  UserList.BeginWriteLock;
  try
    { first, delete UserObject }
    aIndex2 := UserList.IndexOf( AInfo.SessionId );
    if ( aIndex2 >= 0 ) then UserList.Delete( aIndex2 );
    for aIndex := 0 to UserList.Count - 1 do
    begin
      aInfo2 := TLoginInfo( UserList.Objects[aIndex] );
      if IsCompCodeFound( AInfo.CompCode, aInfo2.CompStr ) then
        aEvent.SessionList.Add( aInfo2.SessionId );
    end;
    { second, if state = login, add to the list }
    if ( ( AInfo.Status = '1' ) or ( AInfo.Status = '2' ) ) then
      UserList.AddObject( AInfo.SessionId, AInfo );
    try
      aEvent.UsersChange( Self.ClientID, AInfo );
    except
      on E: Exception do aErrMsg := E.Message;
    end;
  finally
    UserList.EndWriteLock;
  end;
  if ( aErrMsg <> EmptyStr ) then
    ROServerModule.LoginMsgSubject.Error( LanguageManager.GetFmt(
      'SServiceCallbackError1', [aErrMsg] ) );
end;

{ ---------------------------------------------------------------------------- }

end.
