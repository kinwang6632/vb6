unit AnnService_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I Remobjects.inc}

interface

uses
  Classes, SysUtils, Variants, DB,
{ App: }
  cbSrvClass, cbDesignPattern, cbLanguage, cbHrHelper,
{ ODAC: }
  Ora, MemDS, VirtualTable,
{ RemObjects: }
  uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions,
  uRORemoteDataModule, CsHorse2Library_Intf;

type
  { TAnnService }
  TAnnService = class(TRORemoteDataModule, IAnnService)
    procedure RORemoteDataModuleCreate(Sender: TObject);
    procedure RORemoteDataModuleDestroy(Sender: TObject);
  private
    FReader: TOraQuery;
    FBuffer: TVirtualTable;
    function UpdateFromSession(const AInfo: TLoginInfo): TLoginInfo;
    procedure UpdateUserInfo(const AInfo: TLoginInfo);
    {}
    function SO021ToBuffer(const AInfo: TLoginInfo): Binary;
    function CD042ToBuffer(const AInfo: TLoginInfo): Binary;
    function SO022ToBuffer(const AInfo: TLoginInfo): Binary;
    function SO023ToBuffer(const AInfo: TLoginInfo): Binary;
  protected
    { IAnnService methods }
    function GetSOListText(var AInfo: TLoginInfo): String;
    function GetSO021(const AInfo: TLoginInfo): Binary;
    function GetCD042(const AInfo: TLoginInfo): Binary;
    function GetSO022(const AInfo: TLoginInfo): Binary;
    function GetSO023(const AInfo: TLoginInfo): Binary;
  end;

implementation

uses cbUtilis, cbROServerModule;

{$R *.dfm}

{ ---------------------------------------------------------------------------- }

{ AnnService }

procedure TAnnService.RORemoteDataModuleCreate(Sender: TObject);
begin
  FReader := TOraQuery.Create( nil );
  FReader.FetchAll := True;
  FBuffer := TVirtualTable.Create( nil );
end;

{ ---------------------------------------------------------------------------- }

procedure TAnnService.RORemoteDataModuleDestroy(Sender: TObject);
begin
  FReader.Session := nil;
  FReader.Free;
  FBuffer.Free;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.UpdateFromSession(const AInfo: TLoginInfo): TLoginInfo;
begin
  Result := AInfo;
  if ( not Assigned( Result ) ) and ( not VarIsNull( Session.Values['AInfo'] ) ) then
    Result := TLoginInfo( Integer( Session['AInfo'] ) );
end;

{ ---------------------------------------------------------------------------- }

procedure TAnnService.UpdateUserInfo(const AInfo: TLoginInfo);
var
  aDbSession: TDbSession;
  aSql: String;
begin
  TBufferHelper.CreateSqlText( biLoginInfo, aSql );
  aSql := Format( aSql, [AInfo.CompCode, AInfo.UserId] );
  aDbSession := ROServerModule.GetDbSession( AInfo.CompCode );
  if Assigned( aDbSession ) then
  begin
    try
      FReader.Session := aDbSession.Connection;
      FReader.SQL.Text := aSql;
      try
        FReader.Open;
        AInfo.CompStr := FReader.FieldByName( 'compstr' ).AsString;
        AInfo.UserName := FReader.FieldByName( 'username' ).AsString;
        AInfo.CompName := FReader.FieldByName( 'description' ).AsString;
      except
        on E: Exception do aDbSession.Connection.Close;
      end;
    finally
      FReader.Close;
      FReader.Session := nil;
      ROServerModule.ReleaseDbSession( AInfo.CompCode, aDbSession );
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.SO021ToBuffer(const AInfo: TLoginInfo): Binary;
var
  aTemp, aCurrComp, aCompName, aSql, aBoardTime: String;
  aDbSession: TDbSession;
begin
  Result := nil;
  TBufferHelper.CreateFieldDefs( biSO021, FBuffer );
  TBufferHelper.CreateSqlText( biSO021, aSql );
  {}
  aTemp := AInfo.CompStr;
  while ( aTemp <> EmptyStr ) do
  begin
    aCurrComp := ExtractValue( aTemp );
    aCompName := ROServerModule.GetCompName( aCurrComp );
    aDbSession := ROServerModule.GetDbSession( aCurrComp );
    if Assigned( aDbSession ) then
    begin
      FReader.Session := aDbSession.Connection;
      try
        FReader.SQL.Text := Format( aSql, [aCurrComp, aCompName] );
        FReader.Open;
        FReader.First;
        while not FReader.Eof do
        begin
         FBuffer.Append;
         {}
         FBuffer.FieldByName( 'CompCode' ).AsString := FReader.FieldByName( 'CompCode' ).AsString;
         FBuffer.FieldByName( 'CompName' ).AsString := FReader.FieldByName( 'CompName' ).AsString;
         {}
         aBoardTime := EmptyStr;
         if not VarIsNull( FReader.FieldByName( 'BoardTime' ).Value ) then
           aBoardTime := FormatDateTime( 'yyyy/mm/dd hh:nn:ss', FReader.FieldByName( 'BoardTime' ).AsDateTime );
         {}
         FBuffer.FieldByName( 'BoardTime' ).AsString := Format( '發佈時間: %s', [aBoardTime] );
         FBuffer.FieldByName( 'BoardEn' ).AsString := '發佈人: ' + FReader.FieldByName( 'BoardEn' ).AsString;
         FBuffer.FieldByName( 'Subject' ).AsString := '主旨: ' +  FReader.FieldByName( 'Subject' ).AsString;
         FBuffer.FieldByName( 'Content' ).AsString := FReader.FieldByName( 'Content' ).AsString;
         FBuffer.Post;
         FReader.Next;
        end;
        Sleep( 10 );
      finally
        FReader.Close;
        FReader.Session := nil;
        ROServerModule.ReleaseDbSession( aCurrComp, aDbSession );
      end;
    end;
  end;
  if ( not FBuffer.IsEmpty ) then
  begin
    Result := TROBinaryMemoryStream.Create;
    FBuffer.SaveToStream( Result, True );
    FBuffer.Clear;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.GetSO021(const AInfo: TLoginInfo): Binary;
var
  aInfo2: TLoginInfo;
begin
  Result := nil;
  aInfo2 := UpdateFromSession( AInfo );
  if not Assigned( aInfo2 ) then Exit;
  if ( aInfo2.CompStr <> EmptyStr ) then Result := SO021ToBuffer( aInfo2 );
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.GetSOListText(var AInfo: TLoginInfo): String;
var
  aInfo2: TLoginInfo;
  aTemp, aCompCode: String;
  aIndex: Integer;
begin
  Result := aTemp;
  aInfo2 := UpdateFromSession( AInfo );
  if not Assigned( aInfo2 ) then Exit;
  UpdateUserInfo( aInfo2 );
  aTemp := aInfo2.CompStr;
  while ( aTemp <> EmptyStr ) do
  begin
    aCompCode := ExtractValue( aTemp );
    aIndex := ROServerModule.SoList.IndexOf( aCompCode );
    if ( aIndex >= 0 ) then
    begin
      if ( ROServerModule.SoList[aIndex].Selected ) then
      begin
        if ( aCompCode <> EmptyStr ) then
          Result := ( Result + aCompCode + '@' + ROServerModule.GetCompName( aCompCode ) );
        if ( aTemp <> EmptyStr ) then
          Result := ( Result + ',' );
      end;
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.CD042ToBuffer(const AInfo: TLoginInfo): Binary;
var
  aTemp, aCurrComp, aCompName, aSql, aActDateSt, aActDateEd: String;
  aDbSession: TDbSession;
begin
  Result := nil;
  TBufferHelper.CreateFieldDefs( biCD042, FBuffer );
  TBufferHelper.CreateSqlText( biCD042, aSql );
  aTemp := AInfo.CompStr;
  while ( aTemp <> EmptyStr ) do
  begin
    aCurrComp := ExtractValue( aTemp );
    aCompName := ROServerModule.GetCompName( aCurrComp );
    aDbSession := ROServerModule.GetDbSession( aCurrComp );
    if Assigned( aDbSession ) then
    begin
      FReader.Session := aDbSession.Connection;
      try
        FReader.SQL.Text := Format( aSql, [aCurrComp, aCompName] );
        FReader.Open;
        FReader.First;
        while not FReader.Eof do
        begin
          FBuffer.Append;
          FBuffer.FieldByName( 'CompCode' ).AsString := FReader.FieldByName( 'CompCode' ).AsString;
          FBuffer.FieldByName( 'CompName' ).AsString := FReader.FieldByName( 'CompName' ).AsString;
          FBuffer.FieldByName( 'CodeNo' ).AsString := FReader.FieldByName( 'CodeNo' ).AsString;
          {}
          aActDateSt := EmptyStr;
          aActDateEd := EmptyStr;
          if not VarIsNull( FReader.FieldByName( 'ActStartDate' ).Value ) then
            aActDateSt := FormatDateTime( 'yyyy/mm/dd', FReader.FieldByName( 'ActStartDate' ).AsDateTime );
          {}
          if not VarIsNull( FReader.FieldByName( 'ActStopDate' ).Value ) then
            aActDateEd := FormatDateTime( 'yyyy/mm/dd', FReader.FieldByName( 'ActStopDate' ).AsDateTime );
          {}
          FBuffer.FieldByName( 'ActDateStToEd' ).AsString :=
            Format( '活動日期起迄: %s ~ %s', [aActDateSt, aActDateEd] );
          {}
          FBuffer.FieldByName( 'Description' ).AsString :=
            Format( '促案: %s', [FReader.FieldByName( 'Description' ).AsString] );
          {}
          FBuffer.FieldByName( 'Note' ).AsString := '活動說明:'#13#10 + FReader.FieldByName( 'Note' ).AsString;
          {}
          FBuffer.Post;
          FReader.Next;
        end;
       Sleep( 10 );
      finally
        FReader.Close;
        FReader.Session := nil;
        ROServerModule.ReleaseDbSession( aCurrComp, aDbSession );
      end;
    end;
  end;
  if ( not FBuffer.IsEmpty ) then
  begin
    Result := TROBinaryMemoryStream.Create;
    FBuffer.SaveToStream( Result, True );
    FBuffer.Clear;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.GetCD042(const AInfo: TLoginInfo): Binary;
var
  aInfo2: TLoginInfo;
begin
  Result := nil;
  aInfo2 := UpdateFromSession( AInfo );
  if not Assigned( aInfo2 ) then Exit;
  if ( aInfo2.CompStr <> EmptyStr ) then Result := CD042ToBuffer( aInfo2 );
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.SO022ToBuffer(const AInfo: TLoginInfo): Binary;
var
  aTemp, aCurrComp, aCompName, aSql, aErrorTime, aEndTime: String;
  aDbSession: TDbSession;
begin
  Result := nil;
  TBufferHelper.CreateFieldDefs( biSO022, FBuffer );
  TBufferHelper.CreateSqlText( biSO022, aSql );
  aTemp := AInfo.CompStr;
  while ( aTemp <> EmptyStr ) do
  begin
    aCurrComp := ExtractValue( aTemp );
    aCompName := ROServerModule.GetCompName( aCurrComp );
    aDbSession := ROServerModule.GetDbSession( aCurrComp );
    if Assigned( aDbSession ) then
    begin
      FReader.Session := aDbSession.Connection;
      try
        FReader.SQL.Text := Format( aSql, [aCurrComp, aCompName] );
        FReader.Open;
        FReader.First;
        while not FReader.Eof do
        begin
          FBuffer.Append;
          FBuffer.FieldByName( 'CompCode' ).AsString := FReader.FieldByName( 'CompCode' ).AsString;
          FBuffer.FieldByName( 'CompName' ).AsString := FReader.FieldByName( 'CompName' ).AsString;
          FBuffer.FieldByName( 'SNo' ).AsString := FReader.FieldByName( 'SNo' ).AsString;
          {}
          aErrorTime := EmptyStr;
          if not VarIsNull( FReader.FieldByName( 'ErrorTime' ).Value ) then
            aErrorTime := FormatDateTime( 'yyyy/mm/dd hh:nn:ss' , FReader.FieldByName( 'ErrorTime' ).AsDateTime );
          {}
          FBuffer.FieldByName( 'ErrorTime' ).AsString := Format( '故障發生: %s', [aErrorTime] );
          {}
          aEndTime := EmptyStr;
          if not VarIsNull( FReader.FieldByName( 'EndTime' ).Value ) then
            aEndTime := FormatDateTime( 'yyyy/mm/dd hh:nn:ss' , FReader.FieldByName( 'EndTime' ).AsDateTime );
          {}
          FBuffer.FieldByName( 'EndTime' ).AsString := Format( '預計修復: %s', [aEndTime] );
          {}
          FBuffer.FieldByName( 'MfCode' ).AsString := FReader.FieldByName( 'MfCode' ).AsString;
          FBuffer.FieldByName( 'MfName' ).AsString := '故障原因: ' + FReader.FieldByName( 'MfName' ).AsString;
          FBuffer.FieldByName( 'Description' ).AsString := FReader.FieldByName( 'Description' ).AsString;
          FBuffer.FieldByName( 'AcceptName' ).AsString := '受理人: ' + FReader.FieldByName( 'AcceptName' ).AsString;
          FBuffer.Post;
          FReader.Next;
        end;
        Sleep( 10 );
      finally
        FReader.Close;
        FReader.Session := nil;
        ROServerModule.ReleaseDbSession( aCurrComp, aDbSession );
      end;
    end;
  end;
  if ( not FBuffer.IsEmpty ) then
  begin
    Result := TROBinaryMemoryStream.Create;
    FBuffer.SaveToStream( Result, True );
    FBuffer.Clear;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.GetSO022(const AInfo: TLoginInfo): Binary;
var
  aInfo2: TLoginInfo;
begin
  Result := nil;
  aInfo2 := UpdateFromSession( AInfo );
  if not Assigned( aInfo2 ) then Exit;
  if ( aInfo2.CompStr <> EmptyStr ) then Result := SO022ToBuffer( aInfo2 );
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.SO023ToBuffer(const AInfo: TLoginInfo): Binary;
var
  aTemp, aCurrComp, aCompName, aSql, aSNo, aAddress: String;
  aDbSession: TDbSession;
begin
  Result := nil;
  TBufferHelper.CreateFieldDefs( biSO023, FBuffer );
  TBufferHelper.CreateSqlText( biSO023, aSql );
  {}
  aTemp := AInfo.CompStr;
  while ( aTemp <> EmptyStr ) do
  begin
    aCurrComp := ExtractValue( aTemp );
    aCompName := ROServerModule.GetCompName( aCurrComp );
    aDbSession := ROServerModule.GetDbSession( aCurrComp );
    if Assigned( aDbSession ) then
    begin
      FReader.Session := aDbSession.Connection;
      try
        FReader.SQL.Text := Format( aSql, [aCurrComp, aCompName] );
        FReader.Open;
        FReader.First;
        aSNo := FReader.FieldByName( 'SNo' ).AsString;
        while not FReader.Eof do
        begin
          aAddress := aAddress + FReader.FieldByName( 'Address' ).AsString + #13#10;
          FReader.Next;
          if ( aSNo <> FReader.FieldByName( 'SNo' ).AsString ) or
             ( FReader.Eof ) then
          begin
            FBuffer.Append;
            FBuffer.FieldByName( 'CompCode' ).AsString := FReader.FieldByName( 'CompCode' ).AsString;
            FBuffer.FieldByName( 'CompName' ).AsString := FReader.FieldByName( 'CompName' ).AsString;
            FBuffer.FieldByName( 'SNo' ).AsString := aSNo;
            FBuffer.FieldByName( 'Address' ).AsString := aAddress;
            FBuffer.Post;
            aSNo := FReader.FieldByName( 'SNo' ).AsString;
            aAddress := EmptyStr;
          end;
        end;
        Sleep( 10 );
      finally
        FReader.Close;
        FReader.Session := nil;
        ROServerModule.ReleaseDbSession( aCurrComp, aDbSession );
      end;
    end;
  end;
  if ( not FBuffer.IsEmpty ) then
  begin
    Result := TROBinaryMemoryStream.Create;
    FBuffer.SaveToStream( Result, True );
    FBuffer.Clear;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TAnnService.GetSO023(const AInfo: TLoginInfo): Binary;
var
  aInfo2: TLoginInfo;
begin
  Result := nil;
  aInfo2 := UpdateFromSession( AInfo );
  if not Assigned( aInfo2 ) then Exit;
  if ( aInfo2.CompStr <> EmptyStr ) then Result := SO023ToBuffer( aInfo2 );
end;

{ ---------------------------------------------------------------------------- }

end.
